
from __future__ import print_function
import time, requests, json
from requests.auth import HTTPBasicAuth


## default port for bitcoin testnet
## (change to 8332 for 'main net'),
rpcPort = 18332
rpcUser = 'bitcoinrpc'
## not a real password
## but if you use the random password generated by bitcoind
## your password should look something like this
rpcPassword = 'rpc'
btcserverURL = 'http://' + rpcUser + ':' + rpcPassword + '@localhost:' + str(rpcPort)

xcpserverURL = "http://localhost:14000/api/"
auth = HTTPBasicAuth('rpc', 'sweng')

class xcpRPCHost(object):
    def __init__(self, url):
        self._session = requests.Session()
        self._url = url
        self._headers = {'content-type': 'application/json'}
    def call(self, rpcMethod, params):
        print(self)
        print(rpcMethod)
        print(params)
        payload = json.dumps({"method": rpcMethod, "params": params, "jsonrpc": "2.0", "id": 0})
        print (payload)
        tries = 10
        hadConnectionFailures = False
        while True:
            try:
                response = self._session.post(self._url, headers=self._headers, data=payload, auth=auth)
            except requests.exceptions.ConnectionError:
                tries -= 1
                if tries == 0:
                    raise Exception('Failed to connect for remote procedure call.')
                hadFailedConnections = True
                print("Couldn't connect for remote procedure call, will sleep for ten seconds and then try again ({} more tries)".format(tries))
                time.sleep(10)
            else:
                if hadConnectionFailures:
                    print('Connected for remote procedure call after retry.')
                break
        if not response.status_code in (200, 500):
            raise Exception('RPC connection failure: ' + str(response.status_code) + ' ' + response.reason)
        responseJSON = response.json()
        if 'error' in responseJSON and responseJSON['error'] != None:
            raise Exception('Error in RPC call: ' + str(responseJSON['error']))
        return responseJSON['result']

class btcRPCHost(object):
    def __init__(self, url):
        self._session = requests.Session()
        self._url = url
        self._headers = {'content-type': 'application/json'}
    def call(self, rpcMethod, *params):
        payload = json.dumps({"method": rpcMethod, "params": list(params), "jsonrpc": "2.0"})
        tries = 10
        hadConnectionFailures = False
        while True:
            try:
                response = self._session.post(self._url, headers=self._headers, data=payload)
            except requests.exceptions.ConnectionError:
                tries -= 1
                if tries == 0:
                    raise Exception('Failed to connect for remote procedure call.')
                hadFailedConnections = True
                print("Couldn't connect for remote procedure call, will sleep for ten seconds and then try again ({} more tries)".format(tries))
                time.sleep(10)
            else:
                if hadConnectionFailures:
                    print('Connected for remote procedure call after retry.')
                break
        if not response.status_code in (200, 500):
            raise Exception('RPC connection failure: ' + str(response.status_code) + ' ' + response.reason)
        responseJSON = response.json()
        if 'error' in responseJSON and responseJSON['error'] != None:
            raise Exception('Error in RPC call: ' + str(responseJSON['error']))
        return responseJSON['result']


xcpHost = xcpRPCHost(xcpserverURL)
btcHost = btcRPCHost(btcserverURL)


#create a counterparty asset
def createAsset(sourceAddress, assetName, assetQuantity, assetDescription, isDivisible):
	#try:
		objParams = {"source": sourceAddress,
		                      "asset": assetName,
		                      "quantity": assetQuantity,
		                      "description": assetDescription,
		                      "divisible": isDivisible}

		unsignedTransaction = xcpHost.call('create_issuance', objParams)
		print("Unsigned Transaction:", unsignedTransaction)
		return unsignedTransaction
	#except:
	#	print ("Failed. createAsset()")


#sign a raw counterparty transaction output
def signRawTransaction(unsignedTransaction):
	#try:
		hash = btcHost.call('signrawtransaction', unsigned )
		strHex = hash.get('hex')
		print ("Signed Raw Transaction Hex", strHex)
		return strHex
	#except:
	#	print ("Failed. signRawTransaction()")


#broadcast raw bitcoin transaction
def sendRawTransaction(signedTransactionHex):
	#try:
		broadcast = btcHost.call('sendrawtransaction', signedTransactionHex)
		print ("Sent Transaction Hash", broadcast)
		return broadcast
	#except:
	#	print ("Failed. sendRawTransaction()")


#get rawtransaction data
def getRawTransaction(sentTransaction):
	#try:
		rawhash = btcHost.call('getrawtransaction', sentTransaction)
		print("Raw Transaction:", rawhash)
		return rawhash
	#except:
	#	print ("Failed. getRawTransaction()")


# Send 1 XCP (specified in satoshis) from one address to another.
def castVote(userSourceAddress, candidateAddress, assetName, voteQuantity):

	objParams = {"source": userSourceAddress,
	"destination": candidateAddress,
	"asset": assetName,
	"quantity": voteQuantity}
	unsignedTransaction = xcpHost.call('create_send', objParams)
	print("Unsigned Transaction:", unsignedTransaction)
	return unsignedTransaction

def broadcastSignedTransaction(unsignedTransaction):
	signed = signRawTransaction(unsigned)

	sent = sendRawTransaction(signed)

	raw = getRawTransaction(sent)


sourceAddr = "mh4w5JnU662ddHywJU3X1wYL6mufjd6Egz"
assetName = "XLTEST"
assetQuantity = 100000
assetDescription = "This is a test."
isDivisible = False

#candidateAddress = "mfrK1qzYpL6KYqDgXbPdR4ZG1XemWe31av"
candidateAddress = "mqKfr6S5SJgzWcd1kqjdKRzWvUwS8XoR8t"
voteQuantity = 1


#unsigned = createAsset(sourceAddr, assetName, assetQuantity, assetDescription, isDivisible)

unsigned = castVote(sourceAddr, candidateAddress, assetName, voteQuantity)


broadcastSignedTransaction(unsigned)
print("Complete")