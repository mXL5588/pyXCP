
from __future__ import print_function
import time, requests, json
from requests.auth import HTTPBasicAuth


## default port for bitcoin testnet
## (change to 8332 for 'main net'),
rpcPort = 18332
rpcUser = 'bitcoinrpc'
## not a real password
## but if you use the random password generated by bitcoind
## your password should look something like this
rpcPassword = 'rpc'
btcserverURL = 'http://' + rpcUser + ':' + rpcPassword + '@localhost:' + str(rpcPort)

xcpserverURL = "http://localhost:14000/api/"
auth = HTTPBasicAuth('rpc', 'sweng')

class xcpRPCHost(object):
    def __init__(self, url):
        self._session = requests.Session()
        self._url = url
        self._headers = {'content-type': 'application/json'}
    def call(self, rpcMethod, params):
        print(self)
        print(rpcMethod)
        print(params)
        payload = json.dumps({"method": rpcMethod, "params": params, "jsonrpc": "2.0", "id": 0})
        print (payload)
        tries = 10
        hadConnectionFailures = False
        while True:
            try:
                response = self._session.post(self._url, headers=self._headers, data=payload, auth=auth)
            except requests.exceptions.ConnectionError:
                tries -= 1
                if tries == 0:
                    raise Exception('Failed to connect for remote procedure call.')
                hadFailedConnections = True
                print("Couldn't connect for remote procedure call, will sleep for ten seconds and then try again ({} more tries)".format(tries))
                time.sleep(10)
            else:
                if hadConnectionFailures:
                    print('Connected for remote procedure call after retry.')
                break
        if not response.status_code in (200, 500):
            raise Exception('RPC connection failure: ' + str(response.status_code) + ' ' + response.reason)
        responseJSON = response.json()
        if 'error' in responseJSON and responseJSON['error'] != None:
            raise Exception('Error in RPC call: ' + str(responseJSON['error']))
        return responseJSON['result']

class btcRPCHost(object):
    def __init__(self, url):
        self._session = requests.Session()
        self._url = url
        self._headers = {'content-type': 'application/json'}
    def call(self, rpcMethod, *params):
        payload = json.dumps({"method": rpcMethod, "params": list(params), "jsonrpc": "2.0"})
        tries = 10
        hadConnectionFailures = False
        while True:
            try:
                response = self._session.post(self._url, headers=self._headers, data=payload)
            except requests.exceptions.ConnectionError:
                tries -= 1
                if tries == 0:
                    raise Exception('Failed to connect for remote procedure call.')
                hadFailedConnections = True
                print("Couldn't connect for remote procedure call, will sleep for ten seconds and then try again ({} more tries)".format(tries))
                time.sleep(10)
            else:
                if hadConnectionFailures:
                    print('Connected for remote procedure call after retry.')
                break
        if not response.status_code in (200, 500):
            raise Exception('RPC connection failure: ' + str(response.status_code) + ' ' + response.reason)
        responseJSON = response.json()
        if 'error' in responseJSON and responseJSON['error'] != None:
            raise Exception('Error in RPC call: ' + str(responseJSON['error']))
        return responseJSON['result']


xcpHost = xcpRPCHost(xcpserverURL)
btcHost = btcRPCHost(btcserverURL)

objParams = {"source": "mh4w5JnU662ddHywJU3X1wYL6mufjd6Egz",
                      "asset": "CLASSTEST",
                      "quantity": 10,
                      "description": "This is a test asset for the demo",
                      "divisible": False}

unsignedTransaction = xcpHost.call('create_issuance', objParams)
print("Unsigned Transaction:", unsignedTransaction)

hash = btcHost.call('signrawtransaction', unsignedTransaction)

strHex = hash.get('hex')
print("Signed Transaction Hex", strHex)

send = btcHost.call('sendrawtransaction', strHex)
print ("Send Transaction Hash", send)

rawhash = btcHost.call('getrawtransaction', send)

print("Raw Transaction:", rawhash)






